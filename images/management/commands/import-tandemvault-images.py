from django.core.management.base import BaseCommand
from django.utils import timezone
from images.models import *

import math
import logging

import requests
from progress.bar import Bar
from dateutil.parser import *


class Command(BaseCommand):
    help = 'Imports image assets from UCF\'s Tandem Vault instance.'

    progress_bar                = Bar('Processing')
    source                      = 'Tandem Vault'
    azure_source                = 'Azure'
    tandemvault_assets_api_path = '/api/v1/assets/'
    tandemvault_asset_api_path  = '/api/v1/assets/{0}/'
    tandemvault_download_path   = '/assets/{0}/'
    tandemvault_total_images    = 0 # total number of images in Tandem Vault API results
    tandemvault_page_count      = 0 # total number of paged Tandem Vault API results
    images_created              = 0
    images_updated              = 0
    images_deleted              = 0
    images_skipped              = 0
    tags_created                = 0
    tags_updated                = 0
    tags_deleted                = 0

    def add_arguments(self, parser):
        # TODO allow date range or minimum date to be passed in?
        parser.add_argument(
            'domain',
            type=str,
            help='The base domain of UCF\'s Tandem Vault'
        ),
        parser.add_argument(
            '--tandemvault-api-key',
            type=str,
            help='The API key used to connect to Tandem Vault',
            dest='tandemvault-api-key',
            required=True
        ),
        parser.add_argument(
            '--tandemvault-tags-csv-url',
            type=str,
            help='URL that points to a CSV containing existing tag and synonym information from Tandem Vault',
            dest='tandemvault-tags-csv-url',
            required=False
        ),
        parser.add_argument(
            '--azure-api-key',
            type=str,
            help='The API key used to connect to Azure',
            dest='azure-api-key',
            required=False
        ),
        parser.add_argument(
            '--assign-tags',
            type=str,
            help='Specify what images, if any, should be processed with Azure\'s Computer Vision API to generate image tags.',
            dest='assign-tags',
            default='none',
            choices=['all', 'new_modified', 'none'],
            required=False
        ),
        parser.add_argument(
            '--tag-confidence-threshold',
            type=float,
            help='The minimum confidence ranking a tag generated by Azure must have to be assigned to an image. Provide a decimal value between 0 and 1.',
            dest='tag-confidence-threshold',
            default=0,
            required=False
        ),

    def handle(self, *args, **options):
        self.domain = options['domain'].replace('http://', '').replace('https://', '')
        self.tandemvault_api_key = options['tandemvault-api-key']
        self.tandemvault_tags_csv = options['tandemvault-tags-csv-url']
        self.azure_api_key = options['azure-api-key']
        self.assign_tags = options['assign-tags']
        self.tag_confidence_threshold = options['tag-confidence-threshold']

        if self.assign_tags != 'none' and not self.azure_api_key:
            print 'Azure API key required to assign tags via the Computer Vision API. Please provide an Azure API key and try again.'
            return

        if self.assign_tags != 'none' and self.tag_confidence_threshold > 1 or self.tag_confidence_threshold < 0:
            print 'Tag confidence threshold value must be a value between 0 and 1.'
            return

        self.tandemvault_assets_api_url = 'https://' + self.domain + self.tandemvault_assets_api_path
        self.tandemvault_asset_api_url = 'https://' + self.domain + self.tandemvault_asset_api_path
        self.tandemvault_download_url = 'https://' + self.domain + self.tandemvault_download_path

        now = timezone.now()
        self.modified = now
        self.imported = now

        # TODO how to handle start/end dates? Do we always want to use the
        # same start date and force-delete old, existing images?
        self.tandemvault_assets_params = {
            'api_key': self.tandemvault_api_key,
            'state': 'accepted',
            'date[start(1i)]': '2017',
            'date[start(2i)]': '12',
            'date[start(3i)]': '1',
            'date[end(1i)]': self.modified.year,
            'date[end(2i)]': self.modified.month,
            'date[end(3i)]': self.modified.day
        }
        self.tandemvault_asset_params = {
            'api_key': self.tandemvault_api_key
        }

        # If a CSV of existing tags was provided, process it
        if self.tandemvault_tags_csv:
            self.load_tandemvault_tags()

        # Fetch + loop through all Tandem Vault API results
        self.process_images()

        # Delete stale images and image tags
        self.delete_stale()

        # Print the results
        self.progress_bar.finish()
        self.print_stats()

        return

    '''
    Pre-load a CSV of Tandem Vault tags + synonyms.

    TODO
    '''
    def load_tandemvault_tags():
        pass

    '''
    The main image processing function that executes all API
    requests and Image + ImageTag object creation.
    '''
    def process_images(self):
        # Fetch the first page of results, which will set the total number
        # of results and total page count:
        self.process_tandemvault_assets_page(1)

        # Loop through the other pages of results:
        # if self.tandemvault_page_count > 1:
            # for page in range(2, self.tandemvault_page_count):
                # self.process_tandemvault_assets_page(page)

    '''
    Fetches and loops through a single page of assets
    from the Tandem Vault API.
    '''
    def process_tandemvault_assets_page(self, page):
        # Fetch the page:
        page_json = self.fetch_tandemvault_assets_page(page)

        if not page_json:
            logging.warning('Failed to retrieve page %d of Tandem Vault assets. Skipping images.' % page)
            return

        # Process each image in the results:
        for image in page_json:
            self.process_image(image)

    '''
    Processes a single Tandem Vault image.
    '''
    def process_image(self, tandemvault_image):
        self.progress_bar.next()

        download_url = self.tandemvault_download_url.format(tandemvault_image['id'])
        single_json = None

        # Set up the initial Image object.
        try:
            image = Image.objects.get(
                source=self.source,
                source_id=tandemvault_image['id']
            )

            # Check if this image has been modified in Tandem Vault since
            # the last time the image was imported into the Search Service.
            # Only retrieve single image details if changes have been
            # made since the last time the Search Service image was imported:
            tandemvault_image_modified = parse(tandemvault_image['modified_at'])
            if image.last_imported < parse(tandemvault_image['modified_at']):
                # Fetch the single API result
                single_json = self.fetch_tandemvault_asset(tandemvault_image['id'])
                if not single_json:
                    logging.warning('Failed to retrieve single image info for Tandem Vault image with ID %d. Skipping image.' % tandemvault_image['id'])
                    self.images_skipped += 1
                    return

                image.filename = single_json['filename']
                image.extension = single_json['ext']
                image.copyright = single_json['copyright']
                image.contributor = single_json['contributor']['to_s']
                image.width_full = int(single_json['width'])
                image.height_full = int(single_json['height'])
                image.download_url = download_url
                image.thumbnail_url = single_json['grid_url'] # use 'grid_url' instead of 'thumb_url' due to slightly larger size
                image.caption = single_json['short_caption']

                self.images_updated += 1
            else:
                if self.assign_tags == 'all':
                    # Continue processing the image without single image
                    # data; allow tagging via Azure later:
                    self.images_updated += 1
                    logging.info('Skipping retrieval of single image data for image with ID %d since there are no updates, but still assigning tags via Azure.' % tandemvault_image['id'])
                else:
                    image.last_imported = self.imported
                    image.save()

                    # Return here/stop processing the image completely:
                    self.images_skipped += 1
                    logging.info('Skipping image with ID %d entirely, since there are no updates.' % tandemvault_image['id'])
                    return
        except Image.DoesNotExist:
            # Fetch the single API result
            single_json = self.fetch_tandemvault_asset(tandemvault_image['id'])
            if not single_json:
                logging.warning('Failed to retrieve single image info for Tandem Vault image with ID %d. Skipping image.' % tandemvault_image['id'])
                self.images_skipped += 1
                return

            # Create new Image
            image = Image(
                filename = single_json['filename'],
                extension = single_json['ext'],
                source = self.source,
                source_id = single_json['id'],
                copyright = single_json['copyright'],
                contributor=single_json['contributor']['to_s'],
                width_full = int(single_json['width']),
                height_full = int(single_json['height']),
                download_url = download_url,
                thumbnail_url = single_json['grid_url'],
                caption = single_json['short_caption']
            )

            self.images_created += 1

        image.last_imported = self.imported
        image.save()

        # Clear existing set tags imported from Tandem Vault if
        # we retrieved single image data/didn't skip it:
        if single_json:
            image.tags.remove(*image.tags.filter(source=self.source))

        # If Azure Computer Vision tagging is enabled,
        # clear existing tag relationships retrieved from Azure:
        if self.assign_tags != 'none':
            image.tags.remove(*image.tags.filter(source=self.azure_source))

        # Create a unique list of existing tag names to avoid
        # generating duplicates.  Prioritize tags from any other
        # source besides Tandem Vault and Azure.
        tag_names_unique = set([tag.name.lower() for tag in image.tags.all()])

        # Get or create fresh ImageTags based on Tandem Vault's
        # tag list for the image, if we retrieved single
        # image data for the image/didn't skip it:
        if single_json:
            for tandemvault_tag_name in single_json['tag_list']:
                tandemvault_tag_name = tandemvault_tag_name.strip()
                tandemvault_tag_name_lower = tandemvault_tag_name.lower()
                # If this tag doesn't already match the name of another tag
                # assigned to the image, get or create an ImageTag object
                # and assign it to the Image
                if tandemvault_tag_name_lower not in tag_names_unique:
                    tag_names_unique.add(tandemvault_tag_name_lower)
                    tandemvault_tag, created = ImageTag.objects.get_or_create(
                        name=tandemvault_tag_name,
                        source=self.source
                    )
                    image.tags.add(tandemvault_tag)
                    # TODO more tags get flagged 'updated' than 'created'?
                    if created:
                        self.tags_created += 1
                    else:
                        self.tags_updated += 1

        # If Azure Computer Vision tagging is enabled,
        # send the image to Azure:
        if self.assign_tags != 'none':
            azure_data = self.azure_analyze_image(single_json['browse_url'])
            azure_tags = []
            if azure_data:
                azure_tags = azure_data['tags']
            for azure_tag_data in azure_tags:
                azure_tag_name = azure_tag_data['name'].strip()
                azure_tag_name_lower = azure_tag_name.lower()

                # If this tag meets our minimum confidence threshold and
                # doesn't already match the name of another tag assigned to
                # the image, get or create an ImageTag object and assign it
                # to the Image:
                if azure_tag_data.confidence >= self.tag_confidence_threshold and azure_tag_name_lower not in tag_names_unique:
                    tag_names_unique.add(tandemvault_tag_name_lower)
                    azure_tag, created = ImageTag.objects.get_or_create(
                        name=azure_tag_name,
                        source=self.azure_source
                    )
                    image.tags.add(azure_tag)

                    if created:
                        self.tags_created += 1
                    else:
                        self.tags_updated += 1

        image.save()

    '''
    Fetches a single page of results on the Tandem Vault assets API.
    '''
    def fetch_tandemvault_assets_page(self, page):
        params = self.tandemvault_assets_params.copy()
        params.update({
            'page': page
        })

        response_json = None

        try:
            response = requests.get(
                self.tandemvault_assets_api_url,
                params=params
            )
            response_json = response.json()

            # Set some required importer properties if
            # this is the first page request:
            if page == 1:
                self.tandemvault_total_images = int(response.headers['total-results'])
                self.tandemvault_page_count = math.ceil(self.tandemvault_total_images / len(response_json))
                self.progress_bar.max = self.tandemvault_total_images
        except Exception, e:
            logging.warning('\nERROR retrieving assets page data: %s' % e)

        return response_json

    '''
    Fetches an API result for a single Tandem Vault image.
    '''
    def fetch_tandemvault_asset(self, tandemvault_image_id):
        response_json = None

        try:
            response = requests.get(
                self.tandemvault_asset_api_url.format(tandemvault_image_id),
                params=self.tandemvault_asset_params
            )
            response_json = response.json()
        except Exception, e:
            logging.warning('\nERROR retrieving single asset data: %s' % e)

        return response_json

    '''
    Sends an image to Azure's Computer Vision API and returns data about it.

    TODO
    '''
    def azure_analyze_image(self, image_url):
        pass

    '''
    Displays information about the import.
    '''
    def print_stats(self):
        stats = """
Finished import of Tandem Vault images.

Images
---------
Created: {0}
Updated: {1}
Deleted: {2}
Skipped: {3}

Image Tags
-------------
Created: {4}
Updated: {5}
Deleted: {6}
        """.format(
            self.images_created,
            self.images_updated,
            self.images_deleted,
            self.images_skipped,
            self.tags_created,
            self.tags_updated,
            self.tags_deleted
        )

        print(stats)

    '''
    Deletes Image objects sourced from Tandem Vault that are no
    longer present in Tandem Vault, and deletes ImageTags that
    are not assigned to any Images.
    '''
    def delete_stale(self):
        stale_images = Image.objects.filter(
            last_imported__lt=self.imported,
            source=self.source
        )
        stale_tags = ImageTag.objects.filter(images=None)

        self.images_deleted = stale_images.count()
        self.tags_deleted = stale_tags.count()

        stale_images.delete()
        stale_tags.delete()
